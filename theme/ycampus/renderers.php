<?php

defined('MOODLE_INTERNAL') || die();
require_once($CFG->dirroot.'/course/renderer.php');
require_once($CFG->dirroot.'/course/format/renderer.php');

//class theme_ycampus_format_section_renderer_base extends format_topics_renderer {
//
//
//    /**
//     * Generate the section title, wraps it in a link to the section page if page is to be displayed on a separate page
//     *
//     * @param stdClass $section The course_section entry from DB
//     * @param stdClass $course The course entry from DB
//     * @return string HTML to output.
//     */
//    public function section_title($section, $course){
//        //return parent::section_title($section, $course); // TODO: Change the autogenerated stub
//        return '';
//    }
//
//    /**
//     * Generate the display of the header part of a section before
//     * course modules are included
//     *
//     * @param stdClass $section The course_section entry from DB
//     * @param stdClass $course The course entry from DB
//     * @param bool $onsectionpage true if being printed on a single-section page
//     * @param int $sectionreturn The section to return to after an action
//     * @return string HTML to output.
//     */
//    protected function section_header($section, $course, $onsectionpage, $sectionreturn=null) {
////        $o = '';
////        $currenttext = '';
////        $sectionstyle = '';
////
////        if ($section->section != 0) {
////            // Only in the non-general sections.
////            if (!$section->visible) {
////                $sectionstyle = ' hidden';
////            }
////            if (course_get_format($course)->is_section_current($section)) {
////                $sectionstyle = ' current';
////            }
////        }
////
////        $o .= html_writer::start_tag('li', [
////            'id' => 'section-'.$section->section,
////            'class' => 'section main clearfix'.$sectionstyle,
////            'role' => 'region',
////            'aria-labelledby' => "sectionid-{$section->id}-title",
////            'data-sectionid' => $section->section,
////            'data-sectionreturnid' => $sectionreturn
////        ]);
////
////        $leftcontent = $this->section_left_content($section, $course, $onsectionpage);
////        $o.= html_writer::tag('div', $leftcontent, array('class' => 'left side'));
////
////        $rightcontent = $this->section_right_content($section, $course, $onsectionpage);
////        $o.= html_writer::tag('div', $rightcontent, array('class' => 'right side'));
////        $o.= html_writer::start_tag('div', array('class' => 'content'));
////
////        // When not on a section page, we display the section titles except the general section if null
////        $hasnamenotsecpg = (!$onsectionpage && ($section->section != 0 || !is_null($section->name)));
////
////        // When on a section page, we only display the general section title, if title is not the default one
////        $hasnamesecpg = ($onsectionpage && ($section->section == 0 && !is_null($section->name)));
////
////        $classes = ' accesshide';
////        if ($hasnamenotsecpg || $hasnamesecpg) {
////            $classes = '';
////        }
////        $sectionname = html_writer::tag('span', $this->section_title($section, $course));
////        $o .= $this->output->heading($sectionname, 3, 'sectionname' . $classes, "sectionid-{$section->id}-title");
////
////        $o .= $this->section_availability($section);
////
////        $o .= html_writer::start_tag('div', array('class' => 'summary'));
////        if ($section->uservisible || $section->visible) {
////            // Show summary if section is available or has availability restriction information.
////            // Do not show summary if section is hidden but we still display it because of course setting
////            // "Hidden sections are shown in collapsed form".
////            $o .= $this->format_summary_text($section);
////        }
////        $o .= html_writer::end_tag('div');
//
//        return '';
//    }
//
//}

//class theme_ycampus_core_course_renderer extends core_course_renderer{
//
//    /**
//     * Renders html for completion box on course page
//     *
//     * If completion is disabled, returns empty string
//     * If completion is automatic, returns an icon of the current completion state
//     * If completion is manual, returns a form (with an icon inside) that allows user to
//     * toggle completion
//     *
//     * @param stdClass $course course object
//     * @param completion_info $completioninfo completion info for the course, it is recommended
//     *     to fetch once for all modules in course/section for performance
//     * @param cm_info $mod module to show completion for
//     * @param array $displayoptions display options, not used in core
//     * @return string
//     */
//    public function course_section_cm_completion($course, &$completioninfo, cm_info $mod, $displayoptions = array()) {
//        global $CFG, $DB, $USER;
//        $output = '';
//
//        $istrackeduser = $completioninfo->is_tracked_user($USER->id);
//        $isediting = $this->page->user_is_editing();
//
//        if (!empty($displayoptions['hidecompletion']) || !isloggedin() || isguestuser() || !$mod->uservisible) {
//            return $output;
//        }
//        if ($completioninfo === null) {
//            $completioninfo = new completion_info($course);
//        }
//        $completion = $completioninfo->is_enabled($mod);
//
//        if ($completion == COMPLETION_TRACKING_NONE) {
//            if ($isediting) {
//                $output .= html_writer::span('&nbsp;', 'filler');
//            }
//            return $output;
//        }
//
//        $completionicon = '';
//
//        if ($isediting || !$istrackeduser) {
//            switch ($completion) {
//                case COMPLETION_TRACKING_MANUAL :
//                    $completionicon = 'manual-enabled'; break;
//                case COMPLETION_TRACKING_AUTOMATIC :
//                    $completionicon = 'auto-enabled'; break;
//            }
//        } else {
//            $completiondata = $completioninfo->get_data($mod, true);
//            if ($completion == COMPLETION_TRACKING_MANUAL) {
//                switch($completiondata->completionstate) {
//                    case COMPLETION_INCOMPLETE:
//                        $completionicon = 'manual-n' . ($completiondata->overrideby ? '-override' : '');
//                        break;
//                    case COMPLETION_COMPLETE:
//                        $completionicon = 'manual-y' . ($completiondata->overrideby ? '-override' : '');
//                        break;
//                }
//            } else { // Automatic
//                switch($completiondata->completionstate) {
//                    case COMPLETION_INCOMPLETE:
//                        $completionicon = 'auto-n' . ($completiondata->overrideby ? '-override' : '');
//                        break;
//                    case COMPLETION_COMPLETE:
//                        $completionicon = 'auto-y' . ($completiondata->overrideby ? '-override' : '');
//                        break;
//                    case COMPLETION_COMPLETE_PASS:
//                        $completionicon = 'auto-pass'; break;
//                    case COMPLETION_COMPLETE_FAIL:
//                        $completionicon = 'auto-fail'; break;
//                }
//            }
//        }
//        if ($completionicon) {
//            $formattedname = html_entity_decode($mod->get_formatted_name(), ENT_QUOTES, 'UTF-8');
//            if (!$isediting && $istrackeduser && $completiondata->overrideby) {
//                $args = new stdClass();
//                $args->modname = $formattedname;
//                $overridebyuser = \core_user::get_user($completiondata->overrideby, '*', MUST_EXIST);
//                $args->overrideuser = fullname($overridebyuser);
//                $imgalt = get_string('completion-alt-' . $completionicon, 'completion', $args);
//            } else {
//                $imgalt = get_string('completion-alt-' . $completionicon, 'completion', $formattedname);
//            }
//
//            if ($isediting || !$istrackeduser || !has_capability('moodle/course:togglecompletion', $mod->context)) {
//                // When editing, the icon is just an image.
//                $completionpixicon = new pix_icon('i/completion-'.$completionicon, $imgalt, '',
//                    array('title' => $imgalt, 'class' => 'iconsmall'));
//                $output .= html_writer::tag('span', $this->output->render($completionpixicon),
//                    array('class' => 'autocompletion'));
//            } else if ($completion == COMPLETION_TRACKING_MANUAL) {
//                $newstate =
//                    $completiondata->completionstate == COMPLETION_COMPLETE
//                        ? COMPLETION_INCOMPLETE
//                        : COMPLETION_COMPLETE;
//                // In manual mode the icon is a toggle form...
//
//                // If this completion state is used by the
//                // conditional activities system, we need to turn
//                // off the JS.
//                $extraclass = '';
//                if (!empty($CFG->enableavailability) &&
//                    core_availability\info::completion_value_used($course, $mod->id)) {
//                    $extraclass = ' preventjs';
//                }
//                $output .= html_writer::start_tag('form', array('method' => 'post',
//                    'action' => new moodle_url('/course/togglecompletion.php'),
//                    'class' => 'togglecompletion'. $extraclass));
//                $output .= html_writer::start_tag('div');
//                $output .= html_writer::empty_tag('input', array(
//                    'type' => 'hidden', 'name' => 'id', 'value' => $mod->id));
//                $output .= html_writer::empty_tag('input', array(
//                    'type' => 'hidden', 'name' => 'sesskey', 'value' => sesskey()));
//                $output .= html_writer::empty_tag('input', array(
//                    'type' => 'hidden', 'name' => 'modulename', 'value' => $formattedname));
//                $output .= html_writer::empty_tag('input', array(
//                    'type' => 'hidden', 'name' => 'completionstate', 'value' => $newstate));
//                $output .= html_writer::tag('button',
//                    $this->output->pix_icon('i/completion-' . $completionicon, $imgalt),
//                    array('class' => 'btn btn-link', 'aria-live' => 'assertive'));
//                $output .= html_writer::end_tag('div');
//                $output .= html_writer::end_tag('form');
//            } else {
//                // In auto mode, the icon is just an image.
//                $completionpixicon = new pix_icon('i/completion-'.$completionicon, $imgalt, '',
//                    array('title' => $imgalt));
//                $output .= html_writer::tag('span', $this->output->render($completionpixicon),
//                    array('class' => 'autocompletion'));
//            }
//        }
//        return $output;
//    }
//
//    /**
//     * Renders html to display a name with the link to the course module on a course page
//     *
//     * If module is unavailable for user but still needs to be displayed
//     * in the list, just the name is returned without a link
//     *
//     * Note, that for course modules that never have separate pages (i.e. labels)
//     * this function return an empty string
//     *
//     * @param cm_info $mod
//     * @param array $displayoptions
//     * @return string
//     */
//    public function course_section_cm_name_title(cm_info $mod, $displayoptions = array()) {
//        $output = '';
//        $url = $mod->url;
//        if (!$mod->is_visible_on_course_page() || !$url) {
//            // Nothing to be displayed to the user.
//            return $output;
//        }
//
//        //Accessibility: for files get description via icon, this is very ugly hack!
//        $instancename = $mod->get_formatted_name();
//        $altname = $mod->modfullname;
//        // Avoid unnecessary duplication: if e.g. a forum name already
//        // includes the word forum (or Forum, etc) then it is unhelpful
//        // to include that in the accessible description that is added.
//        if (false !== strpos(core_text::strtolower($instancename),
//                core_text::strtolower($altname))) {
//            $altname = '';
//        }
//        // File type after name, for alphabetic lists (screen reader).
//        if ($altname) {
//            $altname = get_accesshide(' '.$altname);
//        }
//
//        list($linkclasses, $textclasses) = $this->course_section_cm_classes($mod);
//
//        // Get on-click attribute value if specified and decode the onclick - it
//        // has already been encoded for display (puke).
//        $onclick = htmlspecialchars_decode($mod->onclick, ENT_QUOTES);
//
//        // Display link itself.
//        $activitylink = html_writer::empty_tag('img', array('src' => $mod->get_icon_url(),
//                'class' => 'iconlarge activityicon', 'alt' => '', 'role' => 'presentation', 'aria-hidden' => 'true')) .
//            html_writer::tag('span', $instancename . $altname, array('class' => 'instancename'));
//        if ($mod->uservisible) {
//            $output .= html_writer::link($url, $activitylink, array('class' => 'aalink' . $linkclasses, 'onclick' => $onclick));
//        } else {
//            // We may be displaying this just in order to show information
//            // about visibility, without the actual link ($mod->is_visible_on_course_page()).
//            $output .= html_writer::tag('div', $activitylink, array('class' => $textclasses));
//        }
//        return $output;
//    }
//
//
//}